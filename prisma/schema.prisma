// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Client {
  id          Int        @id @default(autoincrement())
  name        String
  email       String?    @unique
  phone       String?
  address     String?
  rfc         String?
  curp        String?
  isActive    Boolean   @default(true)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  sales                 Sale []
  productPrice          ClientProductPrice[]
  productPriceHistory   ClientProductPriceHistory[]

  @@index([name])
  @@index([rfc])
  @@index([phone])
  @@index([email])
}

model Product {
  id             Int                @id @default(autoincrement())

  name           String
  description    String?
  sku            String             @unique                // Código interno
  barcode        String?            @unique
  controlled     Boolean            @default(false)        // Medicamento controlado
  stock          Int @default(0)
  minStock       Int @default(5)
  price          Decimal            @db.Decimal(10, 2)     // Precio de VENTA al público
  cost           Decimal            @db.Decimal(10, 2)     // Precio de COMPRA al proveedor

  isActive       Boolean            @default(true)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  // Relación muchos a muchos con categorías
  categories     ProductCategory[]
  
  saleItems                 SaleItem[]
  priceHistory              ProductPriceHistory[]
  purchaseItems             PurchaseItem[]
  clientPrice               ClientProductPrice[]
  clientPriceHistory        ClientProductPriceHistory[]

  @@index([name])
  @@index([sku])
  @@index([barcode])
}

model ProductPriceHistory {
  id          Int          @id @default(autoincrement())

  product     Product      @relation(fields: [productId], references: [id])
  productId   Int
  changedBy   User?        @relation(fields: [changedById], references: [id])
  changedById Int? 

  price       Decimal      @db.Decimal(10, 2)
  startDate   DateTime     @default(now())
  endDate     DateTime?

  @@index([productId])
  @@index([startDate])
}

model Sale {
  id            Int           @id @default(autoincrement())

  client        Client?       @relation(fields: [clientId], references: [id])
  clientId      Int?
  user          User?         @relation(fields: [userId], references: [id])
  userId        Int?

  invoiceNumber String?       @unique   //AAA010101AAA202401000000001  Para CFDI 4.0 en México
  total         Decimal       @db.Decimal(12, 2)
  subtotal      Decimal       @db.Decimal(12, 2)
  flowStatus    SaleFlowStatus @default(DRAFT)
  status        SaleStatus    @default(PENDING)   
  paymentMethod PaymentMethod @default(CASH)
  note          String?

  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  items         SaleItem[]
  payments      SalePayment[]
  saleReturn    SaleReturn[]
  saleRefunds   SaleRefund[]

  @@index([createdAt])
  @@index([invoiceNumber])
  @@index([status])
  @@index([paymentMethod])
}

model SaleItem {
  id            Int         @id @default(autoincrement())

  sale          Sale        @relation(fields: [saleId], references: [id])
  saleId        Int
  product       Product     @relation(fields: [productId], references: [id])
  productId     Int

  quantity      Int
  price         Decimal     @db.Decimal(10, 2) //Precio aplicado
  discount      Decimal     @db.Decimal(10, 2) @default(0)
  subtotal      Decimal     @db.Decimal(10, 2)

  @@index([saleId])
  @@index([productId])
}

model SalePayment {
  id          Int         @id @default(autoincrement())

  sale        Sale        @relation(fields: [saleId], references: [id])
  saleId      Int

  method      PaymentMethod
  amount      Decimal     @db.Decimal(12,2)
  references  String?

  createdAt   DateTime    @default(now())

  @@index([saleId])
  @@index([method])
}

model SaleReturn { 
  id             Int         @id @default(autoincrement())
  
  sale           Sale        @relation(fields: [saleId], references: [id])
  saleId         Int
  processedBy    User?       @relation(fields: [processedById], references: [id])
  processedById  Int?

  note           String?

  createdAt      DateTime   @default(now())

  items          SaleReturnItem[]
  refund         SaleRefund[]
}

model SaleReturnItem {
  id            Int        @id @default(autoincrement())

  saleReturn    SaleReturn @relation(fields: [saleReturnId], references: [id])
  saleReturnId  Int

  saleItemId    Int
  productId     Int
  quantity      Int
  unitPrice     Decimal   @db.Decimal(10, 2)
  subtotal      Decimal   @db.Decimal(12, 2)
  reason        String?
}

model SaleRefund {
  id           Int        @id @default(autoincrement())

  saleReturn   SaleReturn @relation(fields: [saleReturnId], references: [id])
  saleReturnId Int        @unique
  sale         Sale       @relation(fields: [saleId], references: [id])
  saleId       Int

  amount       Decimal    @db.Decimal(12,2)
  method       PaymentMethod?
  reference    String?

  createdAt    DateTime  @default(now())
}

//TODO: Registrar el vuelto en un futuro: CashMovement, CashMovementType, CashMovementCategory 

model Category {
  id           Int         @id @default(autoincrement())
  name         String
  description  String?
  isActive     Boolean     @default(true)

  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt

  // Relación muchos a muchos con productos
  products     ProductCategory[]

  @@unique([name])
  @@index([isActive])
}

// Tabla intermediaria para la relación muchos a muchos entre Product y Category
model ProductCategory {
  id          Int      @id @default(autoincrement())
  
  product     Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId   Int
  
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  categoryId  Int
  
  // Campos adicionales opcionales
  isPrimary   Boolean  @default(false)  // Categoría principal del producto
  order       Int?                      // Orden de importancia de la categoría
  
  createdAt   DateTime @default(now())
  
  @@unique([productId, categoryId])  // Evita duplicados
  @@index([productId])
  @@index([categoryId])
  @@index([isPrimary])
}

model User {
  id          Int          @id @default(autoincrement())

  userName    String       @unique
  password    String
  email       String       @unique
  firstName   String
  lastName    String
  role        UserRole
  isActive    Boolean      @default(true)

  sale                      Sale[]
  productPriceHistory       ProductPriceHistory[]
  clientProductPriceHistory ClientProductPriceHistory[]
  token                     UserToken[]
  saleReturn                SaleReturn[]

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  @@index([userName])
  @@index([email])
}

model Supplier {
  id         Int          @id @default(autoincrement())
  name       String
  contact    String?
  phone      String?
  email      String?      @unique
  isActive   Boolean      @default(true)

  purchases  Purchase[]

  createdAt  DateTime     @default(now())

  @@index([name])
}

model Purchase {
  id            Int             @id @default(autoincrement())

  supplier      Supplier        @relation(fields: [supplierId], references: [id])
  supplierId    Int

  invoiceNumber String
  total         Decimal         @db.Decimal(10, 2)
  subtotal      Decimal         @db.Decimal(10, 2)
  status        PurchaseStatus  @default(PENDING)

  items         PurchaseItem[]
  payments      PurchasePayment[]

  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  @@index([status])
}

model PurchaseItem {
  id          Int         @id @default(autoincrement())

  purchase    Purchase    @relation(fields: [purchaseId], references: [id])
  purchaseId  Int
  product     Product     @relation(fields: [productId], references: [id])
  productId   Int

  quantity    Int
  cost        Decimal     @db.Decimal(10, 2)  // Precio de COMPRA real de este lote
  subtotal    Decimal     @db.Decimal(12, 2)
}

model PurchasePayment {
  id          Int         @id @default(autoincrement())

  purchase    Purchase    @relation(fields: [purchaseId], references: [id])
  purchaseId  Int

  method      PaymentMethod
  amount      Decimal     @db.Decimal(10,2)
  references  String?

  createdAt   DateTime    @default(now())

  @@index([purchaseId])
  @@index([method])
}

model ClientProductPrice { //precios especiales por cliente.
  id         Int          @id @default(autoincrement())

  client     Client       @relation(fields: [clientId], references: [id])
  clientId   Int
  product    Product      @relation(fields: [productId], references: [id])
  productId  Int

  price      Decimal      @db.Decimal(10, 2)
  isActive   Boolean      @default(true)

  createdAt  DateTime     @default(now())

  @@unique([clientId, productId])
  @@index([clientId])
  @@index([productId])
}

model ClientProductPriceHistory {
  id          Int           @id @default(autoincrement())

  client      Client        @relation(fields: [clientId], references: [id])
  clientId    Int
  product     Product       @relation(fields: [productId], references: [id])
  productId   Int
  changedBy   User          @relation(fields: [changedById], references: [id])
  changedById Int

  price       Decimal       @db.Decimal(10, 2)

  startDate   DateTime      @default(now())
  endDate     DateTime?
}

model UserToken {
  id            Int       @id @default(autoincrement())

  user          User      @relation(fields: [userId], references: [id])
  userId        Int

  token         String    @unique
  type          TokenType @default(REFRESH)
  ipAddress     String?
  userAgent     String?
  lastUsedAt    DateTime?
  expiresAt     DateTime
  revoked       Boolean   @default(false)
  revokedAt     DateTime?

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([token])
  @@index([userId])
}

enum TokenType {
  REFRESH          // Para refrescar access tokens
  ACCESS           // Para acceso a recursos (JWT usualmente)
  VERIFICATION     // Para verificar email/cuenta
  PASSWORD_RESET   // Para resetear contraseña
  API              // Tokens de API de larga duración
}

enum UserRole {
  MANAGER 
  ADMIN
  PHARMACIST
  CASHIER
}

enum PaymentMethod {
  CARD
  CASH
  TRANSFER
}

enum SaleStatus {
  PENDING     // Venta registrada pero sin pago
  PARTIAL     // Abonada parcialmente
  COMPLETED   // Pagada completamente
  CANCELLED
  REFUNDED    // Rembolsado
}

enum SaleFlowStatus {
  DRAFT        // Venta abierta, editable
  COMPLETED    // Venta cerrada (stock ya impactado)
  CANCELLED    // Cancelada antes de cerrar
}

enum PurchaseStatus {
  PENDING    // Pedido registrado pero no pagado
  PARTIAL    // Abonado parcialmente
  PAID       // Pagado completamente
  CANCELLED
}